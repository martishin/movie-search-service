// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: movies.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMovieGenre = `-- name: AddMovieGenre :exec
INSERT INTO movies_genres (movie_id, genre_id)
VALUES ($1, $2)
`

type AddMovieGenreParams struct {
	MovieID int32
	GenreID int32
}

func (q *Queries) AddMovieGenre(ctx context.Context, arg AddMovieGenreParams) error {
	_, err := q.db.Exec(ctx, addMovieGenre, arg.MovieID, arg.GenreID)
	return err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (title, release_date, runtime, mpaa_rating, description, image, video)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, release_date, runtime, mpaa_rating, description, image, created_at, updated_at, user_rating, video
`

type CreateMovieParams struct {
	Title       string
	ReleaseDate pgtype.Date
	Runtime     pgtype.Int4
	MpaaRating  pgtype.Text
	Description pgtype.Text
	Image       pgtype.Text
	Video       pgtype.Text
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.Title,
		arg.ReleaseDate,
		arg.Runtime,
		arg.MpaaRating,
		arg.Description,
		arg.Image,
		arg.Video,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ReleaseDate,
		&i.Runtime,
		&i.MpaaRating,
		&i.Description,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserRating,
		&i.Video,
	)
	return i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE
FROM
    movies
WHERE
    id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const deleteMovieGenres = `-- name: DeleteMovieGenres :exec
DELETE
FROM
    movies_genres
WHERE
    movie_id = $1
`

func (q *Queries) DeleteMovieGenres(ctx context.Context, movieID int32) error {
	_, err := q.db.Exec(ctx, deleteMovieGenres, movieID)
	return err
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT id, title, release_date, runtime, mpaa_rating, description, image, created_at, updated_at, user_rating, video
FROM
    movies
WHERE
    id = $1
`

func (q *Queries) GetMovieByID(ctx context.Context, id int32) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ReleaseDate,
		&i.Runtime,
		&i.MpaaRating,
		&i.Description,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserRating,
		&i.Video,
	)
	return i, err
}

const listGenres = `-- name: ListGenres :many
SELECT id, genre, created_at, updated_at
FROM
    genres
ORDER BY
    genre
`

func (q *Queries) ListGenres(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.Query(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Genre,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenresByMovieID = `-- name: ListGenresByMovieID :many
SELECT
    g.id,
    g.genre
FROM
    movies_genres mg
        JOIN genres g ON mg.genre_id = g.id
WHERE
    mg.movie_id = $1
`

type ListGenresByMovieIDRow struct {
	ID    int32
	Genre string
}

func (q *Queries) ListGenresByMovieID(ctx context.Context, movieID int32) ([]ListGenresByMovieIDRow, error) {
	rows, err := q.db.Query(ctx, listGenresByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGenresByMovieIDRow
	for rows.Next() {
		var i ListGenresByMovieIDRow
		if err := rows.Scan(&i.ID, &i.Genre); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, release_date, runtime, mpaa_rating, description, image, created_at, updated_at, user_rating, video
FROM
    movies
ORDER BY
    id
`

func (q *Queries) ListMovies(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ReleaseDate,
			&i.Runtime,
			&i.MpaaRating,
			&i.Description,
			&i.Image,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRating,
			&i.Video,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByGenre = `-- name: ListMoviesByGenre :many
SELECT
    m.id, m.title, m.release_date, m.runtime, m.mpaa_rating, m.description, m.image, m.created_at, m.updated_at, m.user_rating, m.video
FROM
    movies m
        JOIN movies_genres mg ON m.id = mg.movie_id
WHERE
    mg.genre_id = $1
ORDER BY
    m.title
`

func (q *Queries) ListMoviesByGenre(ctx context.Context, genreID int32) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByGenre, genreID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ReleaseDate,
			&i.Runtime,
			&i.MpaaRating,
			&i.Description,
			&i.Image,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRating,
			&i.Video,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesWithGenres = `-- name: ListMoviesWithGenres :many
SELECT
    m.id AS movie_id,
    m.title,
    m.release_date,
    m.runtime,
    m.mpaa_rating,
    m.description,
    m.image,
    m.user_rating,
    m.video,
    g.id AS genre_id,
    g.genre
FROM
    movies m
        LEFT JOIN movies_genres mg ON m.id = mg.movie_id
        LEFT JOIN genres g ON mg.genre_id = g.id
ORDER BY
    m.title
`

type ListMoviesWithGenresRow struct {
	MovieID     int32
	Title       string
	ReleaseDate pgtype.Date
	Runtime     pgtype.Int4
	MpaaRating  pgtype.Text
	Description pgtype.Text
	Image       pgtype.Text
	UserRating  pgtype.Numeric
	Video       pgtype.Text
	GenreID     pgtype.Int4
	Genre       pgtype.Text
}

func (q *Queries) ListMoviesWithGenres(ctx context.Context) ([]ListMoviesWithGenresRow, error) {
	rows, err := q.db.Query(ctx, listMoviesWithGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMoviesWithGenresRow
	for rows.Next() {
		var i ListMoviesWithGenresRow
		if err := rows.Scan(
			&i.MovieID,
			&i.Title,
			&i.ReleaseDate,
			&i.Runtime,
			&i.MpaaRating,
			&i.Description,
			&i.Image,
			&i.UserRating,
			&i.Video,
			&i.GenreID,
			&i.Genre,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesWithGenresAndLikeStatus = `-- name: ListMoviesWithGenresAndLikeStatus :many
SELECT
    m.id AS movie_id,
    m.title,
    m.release_date,
    m.runtime,
    m.mpaa_rating,
    m.description,
    m.image,
    m.user_rating,
    m.video,
    g.id AS genre_id,
    g.genre,
    CASE
    WHEN ulm.user_id IS NOT NULL THEN true
    ELSE false
        END AS is_liked
FROM
    movies m
        LEFT JOIN movies_genres mg ON m.id = mg.movie_id
        LEFT JOIN genres g ON mg.genre_id = g.id
        LEFT JOIN users_like_movies ulm ON m.id = ulm.movie_id AND ulm.user_id = $1
ORDER BY
    m.title, g.genre
`

type ListMoviesWithGenresAndLikeStatusRow struct {
	MovieID     int32
	Title       string
	ReleaseDate pgtype.Date
	Runtime     pgtype.Int4
	MpaaRating  pgtype.Text
	Description pgtype.Text
	Image       pgtype.Text
	UserRating  pgtype.Numeric
	Video       pgtype.Text
	GenreID     pgtype.Int4
	Genre       pgtype.Text
	IsLiked     bool
}

func (q *Queries) ListMoviesWithGenresAndLikeStatus(ctx context.Context, userID int32) ([]ListMoviesWithGenresAndLikeStatusRow, error) {
	rows, err := q.db.Query(ctx, listMoviesWithGenresAndLikeStatus, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMoviesWithGenresAndLikeStatusRow
	for rows.Next() {
		var i ListMoviesWithGenresAndLikeStatusRow
		if err := rows.Scan(
			&i.MovieID,
			&i.Title,
			&i.ReleaseDate,
			&i.Runtime,
			&i.MpaaRating,
			&i.Description,
			&i.Image,
			&i.UserRating,
			&i.Video,
			&i.GenreID,
			&i.Genre,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :exec
UPDATE movies
SET title        = $2,
    release_date = $3,
    runtime      = $4,
    mpaa_rating  = $5,
    description  = $6,
    image        = $7,
    video        = $8
WHERE
    id = $1
`

type UpdateMovieParams struct {
	ID          int32
	Title       string
	ReleaseDate pgtype.Date
	Runtime     pgtype.Int4
	MpaaRating  pgtype.Text
	Description pgtype.Text
	Image       pgtype.Text
	Video       pgtype.Text
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) error {
	_, err := q.db.Exec(ctx, updateMovie,
		arg.ID,
		arg.Title,
		arg.ReleaseDate,
		arg.Runtime,
		arg.MpaaRating,
		arg.Description,
		arg.Image,
		arg.Video,
	)
	return err
}
